'use client';

/* eslint-disable react-hooks/rules-of-hooks */

import { useRef, useEffect } from 'react';
import { useAppContext } from '@/context/AppContext';
import styles from './ΔυαδικήΒροχή.module.css';

const ΔυαδικήΒροχή = ({
  τύποςΟθόνης = 'κανονικό', // 'κανονικό', 'not-found', 'error'
  μέγεθοςΣταγόνων = 14, // px
  ταχύτηταΒροχής = 80, // ms ανά πλαίσιο
  καθυστέρησηΠαραγγελμάτων = 10000, // ms
  πιθανότηταΠαραγγελμάτων = 10, // % (0-100) πιθανότητα εμφάνισης παραγγέλματος ανά στήλη που ξεκινάει
  χρώμαΠαραγγέλματος = '#00fcfd',
  χρώμαΒροχής = '#00fcfd',
  απόσβεσηΠαραγγέλματος = 2500, // επιπλέον απόσβεση μετά την καθυστέρηση (ms)
}) => {
  const canvasRef = useRef(null);
  const { παραγγέλματα = [] } = useAppContext();
  const instanceId = useRef(Math.random().toString(36).slice(2, 9));
  let χρώμαΣταγόνες = χρώμαΒροχής;
  const χαρακτήρες = 'ΑΒΓΔΕϜΖΗΘΙΚΛΜΝΞΟΠϘΡΣΤΥΦΧΨΩͶ├┤ϚϛϻϟϡϠͳ';
  const μέγεθος = Number(μέγεθοςΣταγόνων);
  const ταχυτΒροχής = Number(ταχύτηταΒροχής);
  const καθυστΠαραγγελμάτων = Number(καθυστέρησηΠαραγγελμάτων);
  const πιθανότΠαραγγελμάτων = Number(πιθανότηταΠαραγγελμάτων);
  const απόσβΠαραγγέλματος = Number(απόσβεσηΠαραγγέλματος);

  // υπολογισμός ενεργού χρώματος βροχής (ορισμένοι τύποι οθόνης έχουν προτεραιότητα)
  if (τύποςΟθόνης === 'not-found') χρώμαΣταγόνες = '#ffbb00';
  else if (τύποςΟθόνης === 'error') χρώμαΣταγόνες = '#ad0000';
  else χρώμαΣταγόνες = χρώμαΒροχής;

  // χρώμα Παραγγελμάτων ακολουθεί το χρώμα βροχής (που υπολογίστηκε με βάση τον τύπο οθόνης)
  // Σε σελίδες `not-found`/`error` τα χρώματα έχουν προτεραιότητα.
  // Διαφορετικά, αν δοθεί `χρώμαΠαραγγέλματος` από το wrapper, να το προτιμήσουμε,
  // αλλιώς χρησιμοποιούμε το χρώμα των σταγόνων.
  let χρώμαΠρ;
  if (τύποςΟθόνης === 'not-found') χρώμαΠρ = '#ffbb00';
  else if (τύποςΟθόνης === 'error') χρώμαΠρ = '#ad0000';
  else χρώμαΠρ = χρώμαΠαραγγέλματος || χρώμαΣταγόνες;

  // Καταγραφή instance για τον εντοπισμό διπλών mount/αιτήσεων
  useEffect(() => {
    console.log(`ΔυαδικήΒροχή mount: id=${instanceId.current}`);
    return () => {
      console.log(`ΔυαδικήΒροχή unmount: id=${instanceId.current}`);
    };
  }, []);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const στήλες = Math.floor(canvas.width / μέγεθος);

    const σταγόνες = new Array(στήλες).fill(1);

    // Συνάρτηση για μετατροπή ρήσης σε πίνακα χαρακτήρων με διαχωριστικά
    const μετατροπήΡήσηςΣεΠίνακα = (ρήση) => {
      if (!ρήση) return ['ϟ', 'Ε', 'Π', 'Ο', 'Υ', 'ϟ', 'Θ', 'Ε', 'Ω', 'ϟ'];
      const χαρακτήρες = ρήση.split('');
      const αποτέλεσμα = ['ϟ'];
      χαρακτήρες.forEach((χ) => {
        if (χ === ' ') {
          αποτέλεσμα.push('ϟ');
        } else {
          αποτέλεσμα.push(χ.toUpperCase());
        }
      });
      αποτέλεσμα.push('ϟ');
      return αποτέλεσμα;
    };

    // Πρόταση και κατάσταση για Case Γ
    const ενεργέςΠροτάσεις = {}; // στήλη -> { έναρξη, πρόταση }
    const εμφανίσειςΠαραγγελμάτων = {}; // στήλη -> πόσες φορές ξεκίνησε η πρόταση
    const απόσβεση = []; // { x, y, χαρ, πλαίσιαΥπόλοιπα, συνολοΠλαισίων }
    const χρόνοςΈναρξης = Date.now(); // χρησιμοποιείται για καθυστέρηση πριν την απόσβεση

    const σχεδίαση = () => {
      if (!ctx || !canvas) return;

      ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = χρώμαΣταγόνες;
      ctx.font = `${μέγεθος}px monospace`;

      // βρόχος σχεδίασης βροχής
      for (let i = 0; i < σταγόνες.length; i++) {
        // Ενδεχομένως ξεκίνημα κάθετης Παραγγελμάτων σε ΑΥΤΗ τη στήλη (πιθανότητα % ανά στήλη που ξεκινάει)
        if (
          Math.random() * 100 < πιθανότΠαραγγελμάτων &&
          !ενεργέςΠροτάσεις[i] &&
          παραγγέλματα.length > 0
        ) {
          // Επιλογή τυχαίας ρήσης
          const τυχαίαΡήση =
            παραγγέλματα[Math.floor(Math.random() * παραγγέλματα.length)];
          const κείμενοΡήσης =
            τυχαίαΡήση?.παράγγελμα || τυχαίαΡήση?.ρήση || 'ΕΠΟΥ ΘΕΩ';
          const πίνακαςΠαραγγελμάτων = μετατροπήΡήσηςΣεΠίνακα(κείμενοΡήσης);

          ενεργέςΠροτάσεις[i] = {
            έναρξη: σταγόνες[i],
            πρόταση: πίνακαςΠαραγγελμάτων,
          };
          εμφανίσειςΠαραγγελμάτων[i] = (εμφανίσειςΠαραγγελμάτων[i] || 0) + 1;
        }

        let χαρακτήρας = χαρακτήρες.charAt(
          Math.floor(Math.random() * χαρακτήρες.length)
        );
        let απόΠρόταση = false;

        if (ενεργέςΠροτάσεις[i]) {
          const start = ενεργέςΠροτάσεις[i].έναρξη;
          const πρότασηΠίνακας = ενεργέςΠροτάσεις[i].πρόταση;
          const offset = Math.floor(σταγόνες[i] - start);
          if (offset >= 0 && offset < πρότασηΠίνακας.length) {
            χαρακτήρας = πρότασηΠίνακας[offset];
            απόΠρόταση = true;
          } else if (offset >= πρότασηΠίνακας.length) {
            delete ενεργέςΠροτάσεις[i];
          }
        }

        if (απόΠρόταση) {
          // Αν είναι διαχωριστικό, συμπεριφέρεται ακριβώς όπως κανονικό
          if (χαρακτήρας === 'ϟ') {
            ctx.fillStyle = χρώμαΣταγόνες;
            ctx.fillText(χαρακτήρας, i * μέγεθος, σταγόνες[i] * μέγεθος);
          } else {
            const appearances = εμφανίσειςΠαραγγελμάτων[i] || 0;
            const elapsed = Date.now() - χρόνοςΈναρξης;
            // Αν είναι η πρώτη εμφάνιση Ή είμαστε ακόμα μέσα στο παράθυρο καθυστέρησης,
            // σχεδίαση ακριβώς όπως κανονικά (χωρίς απόσβεση).
            if (appearances <= 1 || elapsed < καθυστΠαραγγελμάτων) {
              // ΠΡΩΤΗ εμφάνιση: διασφάλιση ότι δεν υπάρχουν απόσβεση overlays στο ίδιο σημείο
              for (let k = απόσβεση.length - 1; k >= 0; k--) {
                const αντικείμενο = απόσβεση[k];
                if (
                  αντικείμενο.x === i * μέγεθος &&
                  αντικείμενο.y === σταγόνες[i] * μέγεθος
                )
                  απόσβεση.splice(k, 1);
              }
              // σχεδίαση με χρώμα βροχής (ακολουθεί το χρώμα του τύπου οθόνης)
              ctx.fillStyle = χρώμαΣταγόνες;
              ctx.fillText(χαρακτήρας, i * μέγεθος, σταγόνες[i] * μέγεθος);
            } else {
              // Από τη δεύτερη εμφάνιση και μετά, διατήρηση των γραμμάτων Παραγγελμάτων για περισσότερο
              // πλαίσια απόσβεσης ισοδύναμα με επιπλέον ms μετατρεπόμενα σε πλαίσια
              const πλαίσιαΑπόΚαθυστέρησης = Math.max(
                1,
                Math.round(απόσβΠαραγγέλματος / ταχυτΒροχής)
              );
              const αντικείμενο = {
                x: i * μέγεθος,
                y: σταγόνες[i] * μέγεθος,
                χαρ: χαρακτήρας,
                πλαίσιαΥπόλοιπα: πλαίσιαΑπόΚαθυστέρησης,
                συνολοΠλαισίων: πλαίσιαΑπόΚαθυστέρησης,
              };
              απόσβεση.push(αντικείμενο);
              // σχεδίαση άμεσου επικαλύμματος για αυτό το πλαίσιο χρησιμοποιώντας χρώμα Παραγγελμάτων
              ctx.globalAlpha = 1;
              ctx.fillStyle = χρώμαΠρ;
              ctx.fillText(αντικείμενο.χαρ, αντικείμενο.x, αντικείμενο.y);
              ctx.globalAlpha = 1;
            }
          }
        } else {
          // κανονικός χαρακτήρας βροχής
          ctx.fillStyle = χρώμαΣταγόνες;
          ctx.fillText(χαρακτήρας, i * μέγεθος, σταγόνες[i] * μέγεθος);
        }

        if (σταγόνες[i] * μέγεθος > canvas.height && Math.random() > 0.95) {
          σταγόνες[i] = 0;
        }

        σταγόνες[i]++;
      }

      // απόδοση επικαλυμμάτων απόσβεσης (γράμματα Παραγγελμάτων που παραμένουν περισσότερο)
      for (let λ = απόσβεση.length - 1; λ >= 0; λ--) {
        const αντικείμενο = απόσβεση[λ];
        const t = 1 - αντικείμενο.πλαίσιαΥπόλοιπα / αντικείμενο.συνολοΠλαισίων; // 0..1
        const alpha = 1 - t; // ξεθώριασμα
        ctx.globalAlpha = alpha;
        ctx.fillStyle = χρώμαΠρ;
        ctx.fillText(αντικείμενο.χαρ, αντικείμενο.x, αντικείμενο.y);
        ctx.globalAlpha = 1;
        αντικείμενο.πλαίσιαΥπόλοιπα--;
        if (αντικείμενο.πλαίσιαΥπόλοιπα <= 0) απόσβεση.splice(λ, 1);
      }
    };

    const idΜεσοδιαστήματος = setInterval(σχεδίαση, ταχυτΒροχής);

    function χειριστήςΑναπροσαρμογής() {
      if (!canvas) return;

      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    window.addEventListener('resize', χειριστήςΑναπροσαρμογής);

    return () => {
      window.removeEventListener('resize', χειριστήςΑναπροσαρμογής);
      clearInterval(idΜεσοδιαστήματος);
    };
  }, [
    μέγεθος,
    ταχυτΒροχής,
    πιθανότΠαραγγελμάτων,
    καθυστΠαραγγελμάτων,
    χρώμαΠαραγγέλματος,
    χρώμαΣταγόνες,
    απόσβΠαραγγέλματος,
    τύποςΟθόνης,
    παραγγέλματα,
  ]);

  return <canvas ref={canvasRef} className={styles.canvas} />;
};

export default ΔυαδικήΒροχή;
